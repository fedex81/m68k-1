package de.codesourcery.m68k.emulator.chips;

import de.codesourcery.m68k.emulator.CPU;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

public class IRQController
{
    private static final Logger LOG = LogManager.getLogger( IRQController.class.getName() );

    private final CPU cpu;

    /*
Register Address  Write   Paula         Function
-------- -------  -----   -------       --------
INTREQ     09C      W       P   Interrupt request bits (clear or set)
INTREQR    01E      R       P   Interrupt request bits (read)

                 This register contains interrupt request bits (or
                 flags).  These bits may be polled by the processor;
                 if enabled by the bits listed in the above register,
                 they may cause processor interrupts.  Both a set and
                 clear operation are required to load arbitrary data
                 into this register.  These status bits are not
                 automatically reset when the interrupt is serviced,
                 and must be reset when desired by writing to this
                 address.  The bit assignments are identical to the
                  enable register.

                          Agnus/
                  Read/   Denise/
Register Address  Write   Paula         Function
-------- -------  -----   -------       --------
INTENA     09A      W       P    Interrupt enable bits (clear or set bits)
INTENAR    01C      R       P    Interrupt enable bits (read)

                 This register contains interrupt enable bits. The bit
                 assignment for both the request and enable registers
                 is given below.

                 BIT#  FUNCT  LEVEL DESCRIPTION
                 ----  ------ ----- ----------------------------------
                 15    SET/CLR     Set/clear control bit. Determines if
                                   bits written with a 1 get set or
                                   cleared. Bits written with a zero
                                   are always unchanged.
                 14    INTEN       Master interrupt (enable only, no request)
                 13    EXTER   6   External interrupt
                 12    DSKSYN  5   Disk sync register ( DSKSYNC ) matches disk data
                 11    RBF     5   Serial port receive buffer full
                 10    AUD3    4   Audio channel 3 block finished
                 09    AUD2    4   Audio channel 2 block finished
                 08    AUD1    4   Audio channel 1 block finished
                 07    AUD0    4   Audio channel 0 block finished
                 06    BLIT    3   Blitter finished
                 05    VERTB   3   Start of vertical blank
                 04    COPER   3   Copper
                 03    PORTS   2   I/O ports and timers
                 02    SOFT    1   Reserved for software-initiated interrupt
                 01    DSKBLK  1   Disk block finished
                 00    TBE     1   Serial port transmit buffer empty
     */

    /*

               Exec
Hardware     Software
Priority     Priority     Description                  Name
--------     --------     -----------                  ----
           ____
          |     1         transmitter buffer empty     TBE
          |
   1 -----|     2         disk block complete          DSKBLK
          |
          |     3         software interrupt           SOFTINT
          |----
   2 -----|     4         external INT2 & CIAA         PORTS
          |----
          |     5         graphics coprocessor         COPER
          |
   3 -----|     6         vertical blank interval      VERTB
          |
          |     7         blitter finished             BLIT
          |----
          |     8         audio channel 2              AUD2
          |
          |     9         audio channel 0              AUD0
   4 -----|
          |     10        audio channel 3              AUD3
          |
          |     11        audio channel 1              AUD1
          |----
          |     12        receiver buffer full         RBF
   5 -----|
          |     13        disk sync pattern found      DSKSYNC
          |----
          |     14        external INT6 & CIAB         EXTER
   6 -----|
          |     15        special (master enable)      INTEN
          |----
   7 -----|____ --        non-maskable interrupt       NMI (never generated by Amiga systems)
     */

    public enum IRQSource
    {
        EXTERN( 1 << 13 ),
        DISK_SYNC( 1 << 12 ),
        SERIAL_RCV_BUFFER_FULL( 1 << 11 ),
        AUDIO_CHANNEL3_FINISHED( 1 << 10 ),
        AUDIO_CHANNEL2_FINISHED( 1 << 9 ),
        AUDIO_CHANNEL1_FINISHED( 1 << 8 ),
        AUDIO_CHANNEL0_FINISHED( 1 << 7 ),
        BLITTER_FINISHED( 1 << 6 ),
        VBLANK( 1 << 5 ),
        COPPER( 1 << 4 ),
        PORTS( 1 << 3 ),
        SOFTWARE( 1 << 2 ),
        DISK_BLOCK_FINISHED( 1 << 1 ),
        SERIAL_TX_BUFFER_EMPTY( 1 << 0 );

        public final int bitMask;

        private IRQSource(int bitMask)
        {
            this.bitMask = bitMask;
        }
    }

    public int irqRequests;
    public int irqEnabled;

    public IRQController(CPU cpu)
    {
        this.cpu = cpu;
    }

    public void reset()
    {
        irqRequests = 0;
        irqEnabled = 0;
    }

    public void triggerIRQ(IRQSource source)
    {
        int enabledMask;
        int priority;
        switch ( source )
        {
            case EXTERN:
                enabledMask = 0b0110000000000000;
                priority = 6;
                irqRequests |= 1 << 13;
                break;
            case DISK_SYNC:
                enabledMask = 0b0101000000000000;
                priority = 5;
                irqRequests |= 1 << 12;
                break;
            case SERIAL_RCV_BUFFER_FULL:
                enabledMask = 0b0100100000000000;
                priority = 5;
                irqRequests |= 1 << 11;
                break;
            case AUDIO_CHANNEL3_FINISHED:
                enabledMask = 0b0100010000000000;
                priority = 4;
                irqRequests |= 1 << 10;
                break;
            case AUDIO_CHANNEL2_FINISHED:
                enabledMask = 0b0100001000000000;
                priority = 4;
                irqRequests |= 1 << 9;
                break;
            case AUDIO_CHANNEL1_FINISHED:
                enabledMask = 0b0100000100000000;
                priority = 4;
                irqRequests |= 1 << 8;
                break;
            case AUDIO_CHANNEL0_FINISHED:
                enabledMask = 0b0100000010000000;
                priority = 4;
                irqRequests |= 1 << 7;
                break;
            case BLITTER_FINISHED:
                enabledMask = 0b0100000001000000;
                priority = 3;
                irqRequests |= 1 << 6;
                break;
            case VBLANK:
                enabledMask = 0b0100000000100000;
                priority = 3;
                irqRequests |= 1 << 5;
                break;
            case COPPER:
                enabledMask = 0b0100000000010000;
                priority = 3;
                irqRequests |= 1 << 4;
                break;
            case PORTS:
                enabledMask = 0b0100000000001000;
                priority = 2;
                irqRequests |= 1 << 3;
                break;
            case SOFTWARE:
                enabledMask = 0b0100000000000100;
                priority = 1;
                irqRequests |= 1 << 2;
                break;
            case DISK_BLOCK_FINISHED:
                enabledMask = 0b0100000000000010;
                priority = 1;
                irqRequests |= 1 << 1;
                break;
            case SERIAL_TX_BUFFER_EMPTY:
                enabledMask = 0b0100000000000001;
                priority = 1;
                irqRequests |= 1 << 0;
                break;
            default:
                throw new IllegalArgumentException( "Unhandled IRQ source " + source );
        }
        if ( (irqEnabled & enabledMask) == enabledMask )
        {
            cpu.externalInterrupt( priority );
        }
    }

    public void externalInterrupt(CIA8520 cia)
    {
        /* CIAA can generate INT2.
         * CIAB can generate INT6.
         */
        switch ( cia.name )
        {
            case CIAA:
                cpu.externalInterrupt( 2 );
                break;
            case CIAB:
                cpu.externalInterrupt( 6 );
                break;
            default:
                throw new RuntimeException( "Unreachable code reached" );
        }
    }

    public void writeIRQReq(int value)
    {

        if ( (value & 1 << 15) == 0 )
        {
            // clear bits
            irqRequests &= ~(value & ~(1 << 15));
        }
        else
        {
            // set bits
            irqRequests |= (value & ~(1 << 15));
        }
    }

    public void writeIRQEnable(int value)
    {

        if ( (value & 1 << 15) == 0 )
        {
            // clear bits
            irqEnabled &= ~(value & ~(1 << 15));
        }
        else
        {
            // set bits
            irqEnabled |= (value & ~(1 << 15));
        }
        LOG.info(  "IRQs: " + this  );
    }

    public String toString()
    {
        final StringBuilder result = new StringBuilder();
        final IRQSource[] values = IRQSource.values();
        result.append( "global_enable: " ).append( (irqEnabled & 1 << 14) != 0 );
        result.append( ",enabled: " );
        for (int i = 0, valuesLength = values.length; i < valuesLength; i++)
        {
            final IRQSource src = values[i];
            if ( (irqEnabled & src.bitMask) != 0 )
            {
                result.append( src.name() ).append( "," );
            }
        }
        result.append( ",requested: " );
        for (int i = 0, valuesLength = values.length; i < valuesLength; i++)
        {
            final IRQSource src = values[i];
            if ( (irqRequests & src.bitMask) != 0 )
            {
                result.append( src.name() ).append( "," );
            }
        }
        return result.toString();

    }
}